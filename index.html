<!DOCTYPE html><!--

Simulacra.js
https://github.com/0x8890/simulacra

--><meta charset="utf-8"><title>Simulacra.js</title><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="index.css"><link href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIXx/1Ix7fr/////////////////Me36/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABTR//8o7v3//P////3///////////////////8x7fr/Me36/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABS3/f8N4f7/J+79/+f8/f/t/f7/8v7///X+///6////Lu77/zDu+/8J5P//AAAAAAAAAAAAAAAAAAAAAESx+vwapPr/E9P+/xLq/v+/9/3/F+z9/9H5/f/a+/7/4vv9/w3m/v8P6f7/E87//xLS/v8AAAAAAAAAAAAAAAAAAAAAHpT3/xTF//8J5f//Cub+/5Tz+/+g9Pz/q/b8/xLq/v8Q2f7/Dd3+/xW8/f+d3/+FAAAAAAAAAAAAAAAAAAAAAB+H9v8Vtf3/DN7//wzf/v9L7vr/Xe/6/wXj//8J5f//EMz//xTP/v8UyP7/Gar7/wAAAAAAAAAAAAAAAAAAAAAgfvX/Gqb6/xix+/8Yrfv/Me36/zHt+v8N3f7/DN7//xW9/v8UwP7/HZX4/xyZ+P8AAAAAAAAAAAAAAAAAAAAAIXf0/x2X+P8dlvf/HJ35/xDU/v8N1f7/DNf+/xmp+/8Yrfv/H4b2/x6P9/8AAAAAAAAAAAAAAAAAAAAAAAAAACFx8/8fiPb/IIH1/x6N9/8Szv//Es/+/xLR//8cm/n/IHz0/5TC/A0gfvX/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIWvz/yFt8/8gfvX/E8j//xDJ//8fiPb/H4v2/yF19P8AAAAAGHTz/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKnG+2kiZfL/IH71/xTF//8Vxf//IH71/yFt8/8hbvP/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACB/9f8gfvX/IHz1/yB+9f8iZvL/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkVOr/IH71/yB+9f8kXPH/JF7x/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZF3/8ggPb/JUzk/yVP5v8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJzXU/yc52P8mPdv/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACmuOsSJyvM/wAAAAAAAAAAAAAAAAAAAAAAAAAA/B8AAPAHAADgAwAAwAEAAOABAADgAQAA4AEAAOADAADgCwAA8AsAAPgPAAD8HwAA/B8AAP4fAAD/HwAA/98AAA==" rel="icon" type="image/x-icon"><script src="simulacra.min.js"></script><header><h1>Simulacra.js</h1><h2>One-way data binding for web applications.</h2><code>npm i simulacra --save #v<span class="version">0.14.0</span></code> <a href="simulacra.min.js" class="button">Download</a> <a href="https://github.com/0x8890/simulacra" id="corner"><span>Fork on </span>GitHub</a></header><article><h2 id="synopsis">Synopsis<a class="anchor" href="#synopsis" title="Link to this section “Synopsis”">#</a></h2><p>Simulacra.js makes the DOM react to changes in data. When data changes, it maps those changes to the DOM by adding and removing elements after invoking mutator functions, which by default, assign plain text and form input values.</p><p>Fundamentally, it is a low-cost abstraction over the DOM that optimizes calls to <code>Node.insertBefore</code> and <code>Node.removeChild</code>. The simplicity of its design and execution enable it to perform nearly as well as hand-written DOM manipulation code.</p><h2 id="usage">Usage<a class="anchor" href="#usage" title="Link to this section “Usage”">#</a></h2><p>Simulacra.js uses plain old HTML for templating, and where it shines is that it does not require meta-information in the template at all. For example, the binding is not declared in the template, and there is no loop construct, because it's not necessary. Here's a sample template:</p><pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"product"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"details"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"size"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"vendor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre><p>Using the <code>&lt;template&gt;</code> tag is optional but optimal since its contents are not rendered by default, but any DOM element will suffice. The shape of the data is important since it has a straightforward mapping to the DOM, and arrays are iterated over to output multiple DOM elements. Here's some sample data:</p><pre><code class="lang-js"><span class="hljs-title">var</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = {
  <span class="hljs-title">name</span>: '<span class="hljs-type">Pumpkin</span> <span class="hljs-type">Spice</span> <span class="hljs-type">Latte</span>',
  <span class="hljs-title">details</span>: {
    <span class="hljs-title">size</span>: [ '<span class="hljs-type">Tall</span>', '<span class="hljs-type">Grande</span>', '<span class="hljs-type">Venti</span>' ],
    <span class="hljs-title">vendor</span>: '<span class="hljs-type">Starbucks</span>'
  }</span>
}
</code></pre><p>Simulacra.js exports only a single function, which can either define bindings to the DOM, or apply bindings to an object. If the first argument is an object, it will try to bind the second argument onto the object. If the first argument is either a DOM Node or a CSS selector string, it will return a definition object that is used by Simulacra.js internally, and the second argument then defines either a nested definition or a mutator function. This can be combined in a single expression:</p><pre><code class="lang-js"><span class="hljs-selector-tag">var</span> $ = require(<span class="hljs-string">'simulacra'</span>) <span class="hljs-comment">// or `window.simulacra`</span>

<span class="hljs-selector-tag">var</span> fragment = document.getElementById(<span class="hljs-string">'product'</span>)<span class="hljs-selector-class">.content</span>

<span class="hljs-selector-tag">var</span> <span class="hljs-attribute">content</span> = $(data, $(fragment, {
  name: $(<span class="hljs-string">'.name'</span>),
  <span class="hljs-selector-tag">details</span>: $(<span class="hljs-string">'.details'</span>, {
    size: $(<span class="hljs-string">'.size'</span>),
    vendor: $(<span class="hljs-string">'.vendor'</span>)
  })
}))

document<span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.appendChild</span>(<span class="hljs-attribute">content</span>)
</code></pre><p>The DOM will update if any of the bound keys are assigned a different value, or if any <code>Array.prototype</code> methods on the value are invoked. Arrays and single values may be used interchangeably, the only difference is that Simulacra.js will iterate over array values.</p><p>By default, the value will be assigned to the element's <code>textContent</code> property (or <code>value</code> or <code>checked</code> for inputs), a user-defined mutator function may be used for arbitrary element manipulation. The mutator function may be passed as the second argument to Simulacra.js, it has the signature (<code>node</code>, <code>value</code>, <code>previousValue</code>, <code>path</code>):</p><ul><li><code>node</code>: the local DOM node.</li><li><code>value</code>: the value assigned to the key of the bound object.</li><li><code>previousValue</code>: the previous value assigned to the key of the bound object.</li><li><code>path</code>: an array containing the full path to the value. For example: <code>[ 'users', 2, 'email' ]</code>. Integer values indicate array indices. The root object is accessible at the <code>root</code> property of the path array, i.e. <code>path.root</code>.</li></ul><p>To manipulate a node in a custom way, one may define a mutator function like so:</p><pre><code class="lang-js">$(<span class="hljs-keyword">node</span> <span class="hljs-title">|| selector</span>, function mutator (<span class="hljs-keyword">node</span><span class="hljs-title">, value</span>) {
  <span class="hljs-keyword">node</span>.<span class="hljs-title">textContent</span> = 'Hi ' + value + '!'
})
</code></pre><p>A mutator function can be determined to be an insert, mutate, or remove operation based on whether the value or previous value is <code>null</code>:</p><ul><li>Value but not previous value: insert operation.</li><li>Value and previous value: mutate operation.</li><li>No value: remove operation.</li></ul><p>There are some special cases for the mutator function:</p><ul><li>If the bound node is the same as its parent, its value will not be iterated over if it is an array.</li><li>If the mutator function returns <code>false</code> for a remove operation, then <code>Node.removeChild</code> will not be called. This is useful for implementing animations when removing a Node from the DOM.</li></ul><div><p>Here is the result of the example above:</p><div class="example"><div class="container"><div class="left"><div class="product-container"></div></div><div class="right"><p>Live demo, try it out:</p><ul><li><code>data.name = "Caramel Latte"</code></li><li><code>data.details.size.push("Trenta")</code></li></ul><input type="text" name="eval" placeholder="Change data..."></div></div></div><template id="product"><h1 class="name"></h1><div class="details"><div><span class="size"></span></div><hr><h4 class="vendor"></h4></div></template><script type="text/javascript">(function () {
    window.simulacra.useCommentNode = true
    window.data = {
      name: 'Pumpkin Spice Latte',
      details: {
        meta: {
          date: new Date()
        },
        size: [ 'Tall', 'Grande', 'Venti' ],
        vendor: 'Starbucks'
      }
    }

    var $ = window.simulacra
    var fragment = document.getElementById('product').content

    var output = $(data, $(fragment, {
      name: $('.name'),
      details: $('.details', {
        meta: $('.details', {
          date: $('.details', function (node, value) {
            node.dataset.timestamp = value.getTime()
          })
        }),
        size: $('.size'),
        vendor: $('.vendor')
      })
    }))

    document.querySelector('.product-container').appendChild(output)

    var input = document.querySelector('input[name="eval"]')
    input.addEventListener('keyup', function (event) {
      if (event.keyCode === 13) {
        var x = input.value
        input.value = ''
        eval(x)
      }
    })
  }())</script></div><h2 id="advanced-usage">Advanced Usage<a class="anchor" href="#advanced-usage" title="Link to this section “Advanced Usage”">#</a></h2><p>Since Simulacra.js is intended to be deterministic, the bound object can be cloned at any point in time and bound again to reset to that state. For example, using the <code>clone</code> module:</p><pre><code class="lang-js"><span class="hljs-built_in">var</span> clone = <span class="hljs-keyword">require</span>(<span class="hljs-string">'clone'</span>)
<span class="hljs-built_in">var</span> $ = <span class="hljs-keyword">require</span>(<span class="hljs-string">'simulacra'</span>)

<span class="hljs-built_in">var</span> <span class="hljs-built_in">data</span> = { <span class="hljs-attr">...</span> }, bindings = $( <span class="hljs-attr">...</span> )

<span class="hljs-built_in">var</span> node = $(<span class="hljs-built_in">data</span>, bindings)
<span class="hljs-built_in">var</span> initialData = clone(<span class="hljs-built_in">data</span>)

<span class="hljs-comment">// Do some mutations, and then reset to initial state.</span>
node = $(initialData, bindings)
</code></pre><p>This is just one way to implement time travel, but not the most efficient.</p><h2 id="benchmarks">Benchmarks<a class="anchor" href="#benchmarks" title="Link to this section “Benchmarks”">#</a></h2><p>Simulacra.js is comparable to directly calling <code>Node.appendChild</code> in terms of DOM rendering. Based on the <a href="https://lhorie.github.io/mithril/benchmarks.html">benchmarks</a> from Mithril.js, here's how it compares. Tests ran on a Linux desktop using Chromium. Only loading, scripting, rendering, and aggregate times are shown.</p><div class="table-wrapper"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Loading</th><th style="text-align:left">Scripting</th><th style="text-align:left">Rendering</th><th style="text-align:left">Aggregate</th></tr></thead><tbody><tr><td style="text-align:left"><em>appendChild</em></td><td style="text-align:left">10 ms</td><td style="text-align:left">3 ms</td><td style="text-align:left">13 ms</td><td style="text-align:left">38 ms</td></tr><tr><td style="text-align:left">Simulacra.js</td><td style="text-align:left">9 ms</td><td style="text-align:left">9 ms</td><td style="text-align:left">13 ms</td><td style="text-align:left">39 ms</td></tr><tr><td style="text-align:left">React.js</td><td style="text-align:left">23 ms</td><td style="text-align:left">76 ms</td><td style="text-align:left">13 ms</td><td style="text-align:left">129 ms</td></tr><tr><td style="text-align:left">Mithril.js</td><td style="text-align:left">16 ms</td><td style="text-align:left">77 ms</td><td style="text-align:left">23 ms</td><td style="text-align:left">165 ms</td></tr><tr><td style="text-align:left">Backbone</td><td style="text-align:left">20 ms</td><td style="text-align:left">106 ms</td><td style="text-align:left">23 ms</td><td style="text-align:left">191 ms</td></tr><tr><td style="text-align:left">jQuery</td><td style="text-align:left">20 ms</td><td style="text-align:left">119 ms</td><td style="text-align:left">24 ms</td><td style="text-align:left">211 ms</td></tr><tr><td style="text-align:left">Angular.js</td><td style="text-align:left">17 ms</td><td style="text-align:left">159 ms</td><td style="text-align:left">24 ms</td><td style="text-align:left">295 ms</td></tr></tbody></table></div><p>To run the benchmarks, you will have to clone the repository and build it by running <code>npm run build</code>. The benchmarks are located <a href="https://github.com/0x8890/simulacra/tree/master/benchmark">here</a>.</p><h2 id="how-it-works">How it Works<a class="anchor" href="#how-it-works" title="Link to this section “How it Works”">#</a></h2><p>On initialization, Simulacra.js removes bound elements from the document and replaces them with an empty text node (marker) for memoizing its position. Based on a value in the bound data object, it clones template elements and applies the mutator function on the cloned elements, and appends them near the marker or adjacent nodes.</p><p>When a bound key is assigned, it gets internally casted into an array if it is not an array already, and the values of the array are compared with previous values. Based on whether a value at an index has changed, Simulacra.js will remove, insert, or mutate a DOM Node corresponding to the value. This is faster and simpler than diffing changes between DOM trees.</p><h2 id="caveats">Caveats<a class="anchor" href="#caveats" title="Link to this section “Caveats”">#</a></h2><ul><li>The <code>delete</code> keyword will not trigger a DOM update. Although ES6 <code>Proxy</code> has a trap for this keyword, its browser support is lacking and it can not be polyfilled. Also, it would break the API of Simulacra.js for this one feature, so the recommended practice is to set the value to <code>null</code> rather than trying to <code>delete</code> the key.</li><li>Out-of-bounds array index assignment will not work, because the number of setters is equal to the length of the array.</li><li>The bound data object may not contain any conflicting getters &amp; setters, since they will be overridden by Simulacra.js.</li></ul><h2 id="the-case-against-immutability">The Case Against Immutability<a class="anchor" href="#the-case-against-immutability" title="Link to this section “The Case Against Immutability”">#</a></h2><p>An astute reader may notice that Simulacra.js deals only with mutable objects. Including a library for persistent data structures was considered, but is impractical for many reasons. First, any such library would be larger than Simulacra.js itself, and second, it would be detrimental to performance. For any changes, the differences would have to be calculated per data structure. While it may be useful to save a persistent snapshot of a bound object, it is an expensive operation and shouldn't be the default behavior. Another perspective is that Simulacra.js works with plain old JavaScript, and objects are plain old mutable objects as expected.</p><h2 id="under-the-hood">Under the Hood<a class="anchor" href="#under-the-hood" title="Link to this section “Under the Hood”">#</a></h2><p>This library is written in ES5 syntactically, and makes use of:</p><ul><li>Object.defineProperty (ES5)</li><li>WeakMap (ES6)</li><li>TreeWalker (DOM Level 2)</li><li>Node.isEqualNode (DOM Level 3)</li><li>Node.contains (DOM Living Standard)</li></ul><p>No shims are included. At the bare minimum, it works in IE9+ with a WeakMap polyfill, but otherwise it should work in IE11+.</p><h2 id="server-side-rendering">Server-Side Rendering<a class="anchor" href="#server-side-rendering" title="Link to this section “Server-Side Rendering”">#</a></h2><p>Simulacra.js works in Node.js (it's isomorphic!), with one thing to keep in mind: it should be called within the context of the <code>window</code> global, however this may be optional in some implementations. This is most easily done by using <code>Function.prototype.bind</code>, although <code>Function.prototype.call</code> is more performant. In the following example, <a href="https://github.com/fgnass/domino">Domino</a> is used as the DOM implementation.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> domino = <span class="hljs-built_in">require</span>(<span class="hljs-string">'domino'</span>)
<span class="hljs-keyword">const</span> simulacra = <span class="hljs-built_in">require</span>(<span class="hljs-string">'simulacra'</span>)

<span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = domino.createWindow(<span class="hljs-string">'&lt;h1&gt;&lt;/h1&gt;'</span>)
<span class="hljs-keyword">const</span> $ = simulacra.bind(<span class="hljs-built_in">window</span>)
<span class="hljs-keyword">const</span> data = { message: <span class="hljs-string">'Hello world!'</span> }
<span class="hljs-keyword">const</span> binding = $(<span class="hljs-string">'body'</span>, {
  message: $(<span class="hljs-string">'h1'</span>)
})

<span class="hljs-built_in">console</span>.log($(data, binding).innerHTML)
</code></pre><p>This will print the string <code>&lt;h1&gt;Hello world!&lt;/h1&gt;</code> to <code>stdout</code>.</p><h2 id="license">License<a class="anchor" href="#license" title="Link to this section “License”">#</a></h2><p>This software is licensed under the <a href="https://raw.githubusercontent.com/0x8890/simulacra/master/LICENSE">MIT license</a>.</p></article>